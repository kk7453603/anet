# Протокол ASTP

ASTP (ANet Secure Transport Protocol) — транспортный протокол, разработанный для передачи VPN-трафика через среды с активным анализом и фильтрацией пакетов (DPI).

## Назначение

Стандартные VPN-протоколы (WireGuard, OpenVPN, IPSec) имеют характерные сигнатуры, по которым системы DPI определяют и блокируют их:

- Фиксированные размеры пакетов рукопожатия (например, 148 байт у WireGuard)
- Узнаваемые заголовки и магические числа
- Предсказуемые временные паттерны

ASTP решает эти проблемы: весь трафик протокола представляет собой высокоэнтропийный UDP-поток без фиксированных заголовков, магических чисел и узнаваемых размеров пакетов.

## Используемые алгоритмы

| Назначение | Алгоритм |
| --- | --- |
| Симметричное шифрование | ChaCha20-Poly1305 (AEAD, ключ 256 бит, nonce 96 бит) |
| Обмен ключами | X25519 (Diffie-Hellman на эллиптической кривой Curve25519) |
| Цифровая подпись | Ed25519 |
| Хеширование / KDF | SHA-256 |
| Транспорт туннеля | QUIC (реализация Quinn) |

## Криптографические ключи

В системе используются три типа ключей:

### Ключи подписи Ed25519

Каждый участник (сервер и клиент) обладает долговременной парой Ed25519-ключей:

- **Приватный ключ** — хранится в конфигурационном файле, используется для подписи данных при рукопожатии
- **Публичный ключ** — передаётся контрагенту заранее (вне канала связи)

Клиентский **отпечаток** (fingerprint) вычисляется как `Base64(SHA-256(публичный_ключ)[0..16])` — первые 16 байт SHA-256-хеша публичного ключа. Этот отпечаток используется для идентификации клиента на сервере.

### Эфемерные ключи X25519

Генерируются при каждом новом подключении для обмена по протоколу Diffie-Hellman. Обеспечивают свойство Perfect Forward Secrecy: компрометация долговременных ключей не позволяет расшифровать ранее перехваченный трафик.

### TLS-сертификат сервера

Самоподписанный сертификат Ed25519, необходимый для установления QUIC-соединения. Передаётся клиенту в процессе рукопожатия (фаза IV).

## Установление соединения (рукопожатие)

Рукопожатие состоит из четырёх фаз, которые выполняются по обычному UDP до установления QUIC-туннеля.

Все пакеты рукопожатия зашифрованы **обфускационным ключом** — он вычисляется как `SHA-256(публичный_ключ_сервера)`. Любой наблюдатель, не знающий публичного ключа сервера, видит пакеты как случайные данные.

### Фаза I: клиент → сервер (обмен DH-ключом клиента)

Клиент генерирует эфемерную пару X25519-ключей и отправляет серверу:

- Эфемерный публичный ключ X25519 (32 байта)
- Ed25519-подпись этого ключа (64 байта)
- Долговременный публичный ключ Ed25519 клиента (32 байта)

Всё упаковывается в Protobuf-сообщение, дополняется случайным padding и шифруется обфускационным ключом.

### Фаза II: сервер → клиент (обмен DH-ключом сервера)

Сервер выполняет следующие проверки:

1. Вычисляет отпечаток клиента и проверяет его наличие в списке разрешённых
2. Верифицирует Ed25519-подпись эфемерного ключа

Затем сервер генерирует собственную эфемерную пару X25519, вычисляет общий секрет (Diffie-Hellman) и отправляет клиенту:

- Эфемерный публичный ключ X25519 сервера (32 байта)
- Ed25519-подпись этого ключа (64 байта)

Общий сессионный ключ: `SHA-256(X25519_shared_secret)`.

### Фаза III: клиент → сервер (запрос авторизации)

Клиент верифицирует подпись сервера (используя заранее известный публичный ключ), вычисляет тот же общий секрет и отправляет:

- `AuthRequest` с идентификатором клиента (отпечаток), зашифрованный сессионным ключом

Этот запрос имеет двойное шифрование: внутренний слой — сессионным ключом, внешний слой — обфускационным ключом.

### Фаза IV: сервер → клиент (ответ авторизации)

Сервер проверяет, что идентификатор клиента соответствует отпечатку из фазы I, и отправляет:

- Выделенный IP-адрес, маску подсети, шлюз, MTU
- Идентификатор сессии (16 случайных байт)
- Префикс nonce (4 байта) — уникальный идентификатор клиента для фазы передачи данных
- TLS-сертификат сервера для QUIC

```
КЛИЕНТ                                            СЕРВЕР
   │                                                  │
   │──── Фаза I: DH-ключ клиента + подпись ─────────>│
   │     [обфускационное шифрование]                  │
   │                                                  │ Проверка отпечатка
   │                                                  │ Верификация подписи
   │                                                  │ Генерация DH-ключа сервера
   │<─── Фаза II: DH-ключ сервера + подпись ─────────│
   │     [обфускационное шифрование]                  │
   │                                                  │
   │ Верификация подписи                              │
   │ Вычисление общего секрета                        │
   │                                                  │
   │──── Фаза III: AuthRequest (отпечаток) ──────────>│
   │     [сессионное + обфускационное шифрование]     │
   │                                                  │ Проверка идентификатора
   │                                                  │ Выделение IP, nonce-префикса
   │<─── Фаза IV: AuthResponse (IP, сертификат) ─────│
   │     [сессионное + обфускационное шифрование]     │
   │                                                  │
   │════ QUIC-туннель (зашифрованный UDP) ═══════════>│
```

## Передача данных (туннель)

После завершения рукопожатия клиент устанавливает QUIC-соединение с сервером, используя полученный TLS-сертификат. QUIC-датаграммы дополнительно оборачиваются в слой ASTP-шифрования.

### Формат пакета данных

Каждый UDP-пакет на проводе имеет следующую структуру:

```
┌─────────────┬──────────────────────────────────────────────────┐
│  Nonce       │  Шифротекст ChaCha20-Poly1305                   │
│  (12 байт)   │                                                  │
├─────────────┼──────────────────────────────────────────────────┤
│ prefix │ seq │  seq (8) │ len (2) │ QUIC-данные │ padding │ tag │
│  (4)   │ (8) │          │         │    (N)      │  (P)    │(16) │
└─────────────┴──────────────────────────────────────────────────┘
```

- **Nonce (12 байт)**: `[nonce_prefix (4 байта)][sequence (8 байт, big-endian)]`
- **Шифротекст**: `sequence (8 байт) + длина данных (2 байта, big-endian) + QUIC-payload + padding (нулевые байты)`
- **Tag (16 байт)**: аутентификационный тег Poly1305

Первые 4 байта каждого пакета (nonce-префикс) передаются в открытом виде и позволяют серверу за O(1) определить, какому клиенту принадлежит пакет.

### Фреймирование внутри QUIC

Внутри QUIC-потока IP-пакеты обрамляются длиной:

```
┌─────────────────┬──────────────────────┐
│ Длина (2 байта)  │ IP-пакет (N байт)    │
│ big-endian u16   │                      │
└─────────────────┴──────────────────────┘
```

### Демультиплексирование на сервере

Сервер принимает все пакеты на одном UDP-порту. Для каждого входящего пакета:

1. Читаются первые 4 байта (nonce-префикс)
2. Выполняется поиск клиента в хеш-таблице по префиксу
3. Если клиент найден — пакет расшифровывается и передаётся в QUIC-стек
4. Если клиент не найден и размер пакета достаточен — пакет обрабатывается как рукопожатие

Такой подход позволяет обслуживать рукопожатия и передачу данных на одном и том же порту.

## Противодействие анализу трафика

### Padding (выравнивание размера)

Каждый пакет дополняется до размера, кратного настраиваемому шагу (padding_step). Это скрывает истинный размер передаваемых данных и устраняет характерные размерные паттерны.

### Jitter (временное рассеивание)

Перед отправкой каждого пакета добавляется случайная задержка в заданном диапазоне. Это нарушает временные корреляции между входящими и исходящими потоками данных, затрудняя анализ по таймингам.

Подробнее о настройке этих параметров см. [Маскировка трафика](stealth.md).
